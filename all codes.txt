//textureLoader.js
class TextureLoader {
    constructor() {
        this.textures = {};
        this.loader = new THREE.TextureLoader();
        this.isLoaded = false;
    }

    async loadAllTextures(quality = '2k') {
        console.log('–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã—Ö —Ç–µ–∫—Å—Ç—É—Ä...');
        
        try {
            // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã
            await this.createProceduralTextures();
            this.isLoaded = true;
            console.log('–í—Å–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ');
            return this.textures;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ–∫—Å—Ç—É—Ä:', error);
            // –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
            await this.createFallbackTextures();
            return this.textures;
        }
    }

    async createProceduralTextures() {
        return new Promise((resolve) => {
            // –°–æ–∑–¥–∞–µ–º canvas –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ–∫—Å—Ç—É—Ä
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç—É—Ä—ã
            this.generateSandTexture(ctx, canvas);
            this.textures.sand = new THREE.CanvasTexture(canvas);
            this.textures.sand.name = 'sand';

            this.generateGrassTexture(ctx, canvas);
            this.textures.grass = new THREE.CanvasTexture(canvas);
            this.textures.grass.name = 'grass';

            this.generateRockTexture(ctx, canvas);
            this.textures.rock = new THREE.CanvasTexture(canvas);
            this.textures.rock.name = 'rock';

            this.generateDirtTexture(ctx, canvas);
            this.textures.dirt = new THREE.CanvasTexture(canvas);
            this.textures.dirt.name = 'dirt';

            this.generateWaterTexture(ctx, canvas);
            this.textures.water = new THREE.CanvasTexture(canvas);
            this.textures.water.name = 'water';

            // –°–æ–∑–¥–∞–µ–º –Ω–æ—Ä–º–∞–ª-–º–∞–ø—ã
            this.generateNormalMap(ctx, canvas);
            this.textures.normal_sand = new THREE.CanvasTexture(canvas);
            this.textures.normal_sand.name = 'normal_sand';

            this.textures.normal_rock = this.textures.normal_sand; // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ –Ω–æ—Ä–º–∞–ª-–º–∞–ø—É

            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≤—Å–µ —Ç–µ–∫—Å—Ç—É—Ä—ã
            Object.values(this.textures).forEach(texture => {
                if (texture && texture.isTexture) {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(8, 8);
                    texture.anisotropy = 4;
                }
            });

            resolve();
        });
    }

    generateSandTexture(ctx, canvas) {
        // –û—Å–Ω–æ–≤–∞ - –ø–µ—Å–æ—á–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
        const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        grad.addColorStop(0, '#f4e4a8');
        grad.addColorStop(0.5, '#e6d7a0');
        grad.addColorStop(1, '#d4c18c');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –ø–µ—Å–∫–∞
        ctx.fillStyle = 'rgba(220, 200, 160, 0.4)';
        for (let i = 0; i < 2000; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = 1 + Math.random() * 3;
            ctx.fillRect(x, y, size, size);
        }

        // –ö—Ä—É–ø–Ω—ã–µ –¥–µ—Ç–∞–ª–∏
        ctx.fillStyle = 'rgba(200, 180, 140, 0.3)';
        for (let i = 0; i < 100; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = 5 + Math.random() * 10;
            ctx.fillRect(x, y, size, size);
        }
    }

    generateGrassTexture(ctx, canvas) {
        // –û—Å–Ω–æ–≤–∞ - –∑–µ–ª–µ–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
        const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        grad.addColorStop(0, '#3a7d3a');
        grad.addColorStop(0.5, '#2d5f2d');
        grad.addColorStop(1, '#1f4a1f');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // –¢–µ–∫—Å—Ç—É—Ä–∞ —Ç—Ä–∞–≤—ã
        ctx.fillStyle = 'rgba(70, 150, 70, 0.6)';
        for (let i = 0; i < 1500; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const width = 1 + Math.random() * 2;
            const height = 3 + Math.random() * 8;
            ctx.fillRect(x, y, width, height);
        }

        // –¢–µ–º–Ω—ã–µ –ø—è—Ç–Ω–∞ –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
        ctx.fillStyle = 'rgba(30, 80, 30, 0.4)';
        for (let i = 0; i < 200; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = 10 + Math.random() * 20;
            ctx.fillRect(x, y, size, size);
        }
    }

    generateRockTexture(ctx, canvas) {
        // –û—Å–Ω–æ–≤–∞ - —Å–µ—Ä—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
        const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        grad.addColorStop(0, '#888888');
        grad.addColorStop(0.5, '#666666');
        grad.addColorStop(1, '#555555');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // –¢–µ–∫—Å—Ç—É—Ä–∞ –∫–∞–º–Ω–µ–π
        ctx.fillStyle = 'rgba(100, 100, 100, 0.6)';
        for (let i = 0; i < 800; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = 3 + Math.random() * 12;
            ctx.fillRect(x, y, size, size);
        }

        // –°–≤–µ—Ç–ª—ã–µ –ø—Ä–æ–∂–∏–ª–∫–∏
        ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
        for (let i = 0; i < 100; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const width = 2 + Math.random() * 5;
            const height = 20 + Math.random() * 50;
            ctx.fillRect(x, y, width, height);
        }
    }

    generateDirtTexture(ctx, canvas) {
        // –û—Å–Ω–æ–≤–∞ - –∫–æ—Ä–∏—á–Ω–µ–≤—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
        const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        grad.addColorStop(0, '#8B6B4D');
        grad.addColorStop(0.5, '#6B4F35');
        grad.addColorStop(1, '#5A422B');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // –¢–µ–∫—Å—Ç—É—Ä–∞ –∑–µ–º–ª–∏
        ctx.fillStyle = 'rgba(100, 80, 60, 0.5)';
        for (let i = 0; i < 1200; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = 2 + Math.random() * 6;
            ctx.fillRect(x, y, size, size);
        }

        // –ö–∞–º–Ω–∏ –≤ –∑–µ–º–ª–µ
        ctx.fillStyle = 'rgba(120, 120, 120, 0.4)';
        for (let i = 0; i < 300; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = 3 + Math.random() * 8;
            ctx.fillRect(x, y, size, size);
        }
    }

    generateWaterTexture(ctx, canvas) {
        // –û—Å–Ω–æ–≤–∞ - —Å–∏–Ω–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
        const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        grad.addColorStop(0, '#1a4a8f');
        grad.addColorStop(0.5, '#0f3a7a');
        grad.addColorStop(1, '#082c65');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // –í–æ–ª–Ω—ã/—Ä—è–±—å
        ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 50; i++) {
            ctx.beginPath();
            const centerX = Math.random() * canvas.width;
            const centerY = Math.random() * canvas.height;
            const radius = 10 + Math.random() * 40;
            
            for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                const variance = Math.sin(angle * 8) * 3;
                const x = centerX + Math.cos(angle) * (radius + variance);
                const y = centerY + Math.sin(angle) * (radius + variance);
                
                if (angle === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
        }
    }

    generateNormalMap(ctx, canvas) {
        // –ü—Ä–æ—Å—Ç–∞—è –Ω–æ—Ä–º–∞–ª-–º–∞–ø–∞ (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–æ–µ–∫—Ç–µ –Ω—É–∂–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã—Å–æ—Ç)
        const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        grad.addColorStop(0, '#7f7fff');
        grad.addColorStop(0.5, '#8080ff');
        grad.addColorStop(1, '#7f7fff');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–º–Ω–æ–≥–æ –≤–∞—Ä–∏–∞—Ü–∏–π –¥–ª—è —Ç–µ–∫—Å—Ç—É—Ä—ã
        ctx.fillStyle = 'rgba(127, 127, 255, 0.1)';
        for (let i = 0; i < 500; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = 5 + Math.random() * 15;
            ctx.fillRect(x, y, size, size);
        }
    }

    async createFallbackTextures() {
        // –°–æ–∑–¥–∞–µ–º –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        // –ü—Ä–æ—Å—Ç—ã–µ —Ü–≤–µ—Ç–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã
        const textures = {
            'sand': '#f4e4a8',
            'grass': '#3a7d3a',
            'rock': '#888888',
            'dirt': '#8B6B4D',
            'water': '#1a4a8f',
            'normal_sand': '#7f7fff',
            'normal_rock': '#7f7fff'
        };

        for (const [name, color] of Object.entries(textures)) {
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            this.textures[name] = new THREE.CanvasTexture(canvas);
            this.textures[name].name = name;
            
            // –ë–∞–∑–æ–≤–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞
            this.textures[name].wrapS = THREE.RepeatWrapping;
            this.textures[name].wrapT = THREE.RepeatWrapping;
            this.textures[name].repeat.set(8, 8);
        }

        this.isLoaded = true;
    }

    getTexture(name) {
        if (!this.textures[name]) {
            console.warn(`–¢–µ–∫—Å—Ç—É—Ä–∞ "${name}" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞`);
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ª—é–±—É—é –¥–æ—Å—Ç—É–ø–Ω—É—é —Ç–µ–∫—Å—Ç—É—Ä—É –∫–∞–∫ fallback
            return this.textures[Object.keys(this.textures)[0]] || null;
        }
        return this.textures[name];
    }

    dispose() {
        Object.values(this.textures).forEach(texture => {
            if (texture && texture.dispose) {
                texture.dispose();
            }
        });
        this.textures = {};
        this.isLoaded = false;
    }
}

//style.css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #333;
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 1800px;
    margin: 0 auto;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 15px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    overflow: hidden;
}

header {
    background: linear-gradient(135deg, #2c3e50, #34495e);
    color: white;
    padding: 25px;
    text-align: center;
}

header h1 {
    font-size: 2.2em;
    margin-bottom: 8px;
    font-weight: 300;
}

header p {
    font-size: 1.1em;
    opacity: 0.9;
}

/* –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
.controls-panel {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    padding: 25px;
    background: #f8f9fa;
    border-bottom: 1px solid #e9ecef;
}

.control-section {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    border: 1px solid #e9ecef;
}

.control-section h3 {
    margin: 0 0 18px 0;
    color: #2c3e50;
    font-size: 15px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
}

.control-group {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
    gap: 10px;
}

.control-group label {
    min-width: 120px;
    font-weight: 500;
    color: #495057;
    font-size: 14px;
}

input[type="number"],
select {
    padding: 8px 12px;
    border: 1px solid #ced4da;
    border-radius: 6px;
    font-size: 14px;
    width: 80px;
    background: white;
}

input[type="range"] {
    flex: 1;
    height: 6px;
    background: #dee2e6;
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    background: #4dabf7;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    background: #4dabf7;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

button {
    padding: 10px 16px;
    background: linear-gradient(135deg, #4dabf7, #339af0);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 6px;
    justify-content: center;
}

button:hover {
    background: linear-gradient(135deg, #339af0, #228be6);
    transform: translateY(-1px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

button.active {
    background: linear-gradient(135deg, #228be6, #1c7ed6);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

.generate-btn {
    width: 100%;
    padding: 14px;
    background: linear-gradient(135deg, #51cf66, #40c057);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    margin-top: 10px;
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
}

.generate-btn:hover {
    background: linear-gradient(135deg, #40c057, #37b24d);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
}

/* –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã */
.tool-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 15px;
}

.tool-btn {
    padding: 10px 12px;
    background: #e9ecef;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    transition: all 0.2s ease;
}

.tool-btn.active {
    background: #4dabf7;
    color: white;
    border-color: #4dabf7;
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(77, 171, 247, 0.4);
}

.tool-btn:hover:not(.active) {
    background: #dee2e6;
    transform: translateY(-1px);
}

/* –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∏–¥–æ–º */
.view-controls {
    display: flex;
    gap: 10px;
    margin-top: 12px;
}

.view-controls button {
    flex: 1;
    padding: 8px 12px;
    background: #e9ecef;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    color: #495057;
}

.view-controls button.active {
    background: #4dabf7;
    color: white;
    border-color: #4dabf7;
}

/* –ó–∞–≥—Ä—É–∑–∫–∞ */
.loading {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 30px;
    border-radius: 12px;
    z-index: 1000;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.1);
}

.loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid rgba(255,255,255,0.3);
    border-top: 4px solid #4dabf7;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loading-text {
    font-size: 16px;
    font-weight: 500;
}

.loading-progress {
    margin-top: 10px;
    font-size: 14px;
    color: #4dabf7;
    font-weight: bold;
}

/* –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è */
.visualization {
    padding: 25px;
}

.canvas-container {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
    position: relative;
}

#threeContainer {
    width: 100%;
    height: 600px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    background: linear-gradient(180deg, #87CEEB 0%, #98D8F0 100%);
    position: relative;
}

/* –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ö */
.tool-info {
    position: absolute;
    top: 15px;
    left: 15px;
    background: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    font-size: 12px;
    z-index: 100;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.1);
}

.tool-info div {
    margin: 4px 0;
    display: flex;
    align-items: center;
    gap: 6px;
}

/* –õ–µ–≥–µ–Ω–¥–∞ */
.legend {
    display: flex;
    justify-content: space-around;
    margin-top: 15px;
    font-size: 12px;
    color: #6c757d;
    flex-wrap: wrap;
    gap: 12px;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 6px;
}

.legend span {
    display: flex;
    align-items: center;
    gap: 5px;
    font-weight: 500;
}

/* –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ */
.stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 12px;
    background: #e9ecef;
    padding: 18px;
    border-radius: 8px;
    font-weight: 500;
}

.stats div {
    color: #495057;
    text-align: center;
    font-size: 13px;
    background: white;
    padding: 10px;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

/* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å */
@media (max-width: 1200px) {
    .controls-panel {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (max-width: 768px) {
    .controls-panel {
        grid-template-columns: 1fr;
    }
    
    .control-group {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .control-group label {
        min-width: auto;
        margin-bottom: 5px;
    }
    
    input[type="range"] {
        width: 100%;
    }
    
    .tool-buttons {
        grid-template-columns: 1fr;
    }
    
    .stats {
        grid-template-columns: repeat(2, 1fr);
    }
    
    #threeContainer {
        height: 400px;
    }
    
    header h1 {
        font-size: 1.8em;
    }
    
    .legend {
        justify-content: flex-start;
    }
}

@media (max-width: 480px) {
    .container {
        margin: 10px;
        padding: 0;
    }
    
    .controls-panel {
        padding: 15px;
    }
    
    .visualization {
        padding: 15px;
    }
    
    .stats {
        grid-template-columns: 1fr;
    }
    
    #threeContainer {
        height: 300px;
    }
}

/* –°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ —Å—Ç–∏–ª–∏ –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
#randomSeed {
    padding: 8px 12px;
    font-size: 13px;
}

#export, #screenshot {
    width: 100%;
    margin-bottom: 8px;
    justify-content: center;
}

/* –°—Ç–∏–ª–∏ –¥–ª—è –ø–æ–ª–∑—É–Ω–∫–æ–≤ –∑–Ω–∞—á–µ–Ω–∏–π */
.control-group span {
    min-width: 40px;
    text-align: center;
    font-weight: 600;
    color: #4dabf7;
    background: #f8f9fa;
    padding: 4px 8px;
    border-radius: 4px;
    border: 1px solid #e9ecef;
}

/* –ê–Ω–∏–º–∞—Ü–∏–∏ */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.control-section {
    animation: fadeIn 0.3s ease-out;
}

/* –ö–∞—Å—Ç–æ–º–Ω—ã–π —Å–∫—Ä–æ–ª–ª–±–∞—Ä */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}
/* –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π style.css */

.control-section h3 {
    margin: 0 0 18px 0;
    color: #2c3e50;
    font-size: 15px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
}

.control-section h3::before {
    font-size: 16px;
}

/* –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –∏–∫–æ–Ω–∫–∏ –¥–ª—è —Å–µ–∫—Ü–∏–π */
.control-section:nth-child(1) h3::before { content: "üé≤"; }
.control-section:nth-child(2) h3::before { content: "‚öôÔ∏è"; }
.control-section:nth-child(3) h3::before { content: "üî∑"; }
.control-section:nth-child(4) h3::before { content: "üèîÔ∏è"; }
.control-section:nth-child(5) h3::before { content: "üé®"; }
.control-section:nth-child(6) h3::before { content: "üíæ"; }

.stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 12px;
    background: #e9ecef;
    padding: 18px;
    border-radius: 8px;
    font-weight: 500;
}

.stats div {
    color: #495057;
    text-align: center;
    font-size: 13px;
    background: white;
    padding: 10px;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

#algorithmInfo {
    background: linear-gradient(135deg, #4dabf7, #339af0);
    color: white;
    font-weight: 600;
}

//terrainEditor.js
class TerrainEditor {
    constructor(threeRenderer, terrainGenerator) {
        this.renderer = threeRenderer;
        this.generator = terrainGenerator;
        this.currentTool = 'select';
        this.isEditing = false;
        this.brushSize = 10;
        this.brushStrength = 0.3;
        this.originalHeightmap = null;
        
        this.initEventListeners();
    }

    initEventListeners() {
        // –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
        document.getElementById('toolSmooth').addEventListener('click', () => this.setTool('smooth'));
        document.getElementById('toolRaise').addEventListener('click', () => this.setTool('raise'));
        document.getElementById('toolLower').addEventListener('click', () => this.setTool('lower'));
        document.getElementById('toolReset').addEventListener('click', () => this.resetTerrain());

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∏—Å—Ç–∏
        document.getElementById('brushSize').addEventListener('input', (e) => {
            this.brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = this.brushSize;
        });

        document.getElementById('brushStrength').addEventListener('input', (e) => {
            this.brushStrength = parseInt(e.target.value) / 100;
            document.getElementById('brushStrengthValue').textContent = Math.round(this.brushStrength * 100) + '%';
        });

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤ –ø–æ —Ç–µ—Ä—Ä–µ–π–Ω—É
        this.setupTerrainInteraction();
    }

    setupTerrainInteraction() {
        const canvas = this.renderer.renderer.domElement;
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0 && this.currentTool !== 'select') { // –õ–ö–ú
                this.isEditing = true;
                this.applyToolAtMouse(e);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (this.isEditing && this.currentTool !== 'select') {
                this.applyToolAtMouse(e);
            }
        });

        canvas.addEventListener('mouseup', () => {
            this.isEditing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            this.isEditing = false;
        });
    }

    setTool(tool) {
        this.currentTool = tool;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º UI
        document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`tool${tool.charAt(0).toUpperCase() + tool.slice(1)}`).classList.add('active');
        
        document.getElementById('currentTool').textContent = `–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: ${
            tool === 'smooth' ? '–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ' :
            tool === 'raise' ? '–ü–æ–¥–Ω—è—Ç—å' :
            tool === 'lower' ? '–û–ø—É—Å—Ç–∏—Ç—å' : '–í—ã–±–æ—Ä'
        }`;
    }

    applyToolAtMouse(event) {
        if (!this.generator.currentHeightmap || !this.renderer.terrain) return;

        const mouse = this.getMousePosition(event);
        const intersection = this.getTerrainIntersection(mouse);

        if (intersection) {
            this.modifyTerrainAtPoint(intersection.point);
        }
    }

    getMousePosition(event) {
        const rect = this.renderer.renderer.domElement.getBoundingClientRect();
        return {
            x: ((event.clientX - rect.left) / rect.width) * 2 - 1,
            y: -((event.clientY - rect.top) / rect.height) * 2 + 1
        };
    }

    getTerrainIntersection(mouse) {
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.renderer.camera);
        
        const intersects = raycaster.intersectObject(this.renderer.terrain);
        return intersects.length > 0 ? intersects[0] : null;
    }

    modifyTerrainAtPoint(point) {
        const terrain = this.renderer.terrain;
        const geometry = terrain.geometry;
        const vertices = geometry.attributes.position.array;
        const heightmap = this.generator.currentHeightmap;
        const size = Math.sqrt(heightmap.length);
        const heightScale = parseInt(document.getElementById('heightScale').value);

        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ª–æ–∫–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–µ—Ä—Ä–µ–π–Ω–∞
        const localPoint = point.clone();
        terrain.worldToLocal(localPoint);

        const centerX = localPoint.x + size / 2;
        const centerY = -localPoint.z + size / 2;

        let modified = false;

        for (let i = 0; i < vertices.length; i += 3) {
            const vertexX = vertices[i] + size / 2;
            const vertexY = vertices[i + 1] + size / 2;
            
            const distance = Math.sqrt(
                Math.pow(vertexX - centerX, 2) + 
                Math.pow(vertexY - centerY, 2)
            );

            if (distance < this.brushSize) {
                const influence = 1 - (distance / this.brushSize);
                const strength = this.brushStrength * influence;

                // –ù–∞—Ö–æ–¥–∏–º –∏–Ω–¥–µ–∫—Å –≤ –∫–∞—Ä—Ç–µ –≤—ã—Å–æ—Ç
                const heightmapIndex = Math.floor(vertexY) * size + Math.floor(vertexX);
                
                if (heightmapIndex >= 0 && heightmapIndex < heightmap.length) {
                    const currentHeight = heightmap[heightmapIndex];
                    let newHeight = currentHeight;

                    switch (this.currentTool) {
                        case 'raise':
                            newHeight = Math.min(1, currentHeight + strength * 0.1);
                            break;
                        case 'lower':
                            newHeight = Math.max(0, currentHeight - strength * 0.1);
                            break;
                        case 'smooth':
                            // –ü—Ä–æ—Å—Ç–æ–µ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ - —É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ —Å —Å–æ—Å–µ–¥—è–º–∏
                            const avgHeight = this.getAverageHeight(heightmap, size, Math.floor(vertexX), Math.floor(vertexY));
                            newHeight = currentHeight + (avgHeight - currentHeight) * strength;
                            break;
                    }

                    heightmap[heightmapIndex] = newHeight;
                    vertices[i + 2] = newHeight * heightScale;
                    modified = true;
                }
            }
        }

        if (modified) {
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç–∞
            this.renderer.addDetailedVertexColors(geometry, heightScale);
            geometry.attributes.color.needsUpdate = true;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            this.generator.updateStats(heightmap, 0);
        }
    }

    getAverageHeight(heightmap, size, x, y) {
        let sum = 0;
        let count = 0;

        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const nx = Math.max(0, Math.min(size - 1, x + dx));
                const ny = Math.max(0, Math.min(size - 1, y + dy));
                sum += heightmap[ny * size + nx];
                count++;
            }
        }

        return sum / count;
    }

    resetTerrain() {
        if (this.originalHeightmap && this.generator.currentHeightmap) {
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É –≤—ã—Å–æ—Ç
            this.generator.currentHeightmap.set(this.originalHeightmap);
            this.updateTerrainFromHeightmap();
        }
    }

    saveOriginalHeightmap() {
        if (this.generator.currentHeightmap) {
            this.originalHeightmap = new Float32Array(this.generator.currentHeightmap);
        }
    }

    updateTerrainFromHeightmap() {
        if (!this.renderer.terrain || !this.generator.currentHeightmap) return;

        const terrain = this.renderer.terrain;
        const geometry = terrain.geometry;
        const vertices = geometry.attributes.position.array;
        const heightmap = this.generator.currentHeightmap;
        const size = Math.sqrt(heightmap.length);
        const heightScale = parseInt(document.getElementById('heightScale').value);

        for (let i = 0, j = 0; i < vertices.length; i += 3, j++) {
            if (j < heightmap.length) {
                vertices[i + 2] = heightmap[j] * heightScale;
            }
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals();
        
        this.renderer.addDetailedVertexColors(geometry, heightScale);
        geometry.attributes.color.needsUpdate = true;
        
        this.generator.updateStats(heightmap, 0);
    }
}

//threeRenderer.js
class ThreeRenderer {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.terrain = null;
        this.lights = [];
        this.isInitialized = false;
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        
        this.init();
    }

    async init() {
        try {
            console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js –¥–ª—è –≤—ã—Å–æ–∫–æ–≥–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è...');

            // –°–æ–∑–¥–∞–µ–º —Å—Ü–µ–Ω—É
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x87CEEB);
            this.scene.fog = new THREE.Fog(0x87CEEB, 100, 1000);

            // –°–æ–∑–¥–∞–µ–º –∫–∞–º–µ—Ä—É
            this.camera = new THREE.PerspectiveCamera(
                60,
                this.container.clientWidth / this.container.clientHeight, 
                0.1, 
                5000
            );
            this.camera.position.set(0, 400, 400);

            // –°–æ–∑–¥–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–µ—Ä —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏
            this.renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance",
                precision: "mediump"
            });
            this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.renderer.physicallyCorrectLights = true;
            this.renderer.outputEncoding = THREE.sRGBEncoding;
            
            this.container.innerHTML = '';
            this.container.appendChild(this.renderer.domElement);

            // –î–æ–±–∞–≤–ª—è–µ–º OrbitControls
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            this.controls.minDistance = 50;
            this.controls.maxDistance = 2000;
            this.controls.screenSpacePanning = false;

            // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å–≤–µ—â–µ–Ω–∏–µ
            this.setupHighQualityLighting();

            this.isInitialized = true;
            this.animate();

            console.log('Three.js —Å—Ü–µ–Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è –≤—ã—Å–æ–∫–æ–≥–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è');

        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Three.js:', error);
        }
    }

    setupHighQualityLighting() {
        // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞
        this.lights.forEach(light => this.scene.remove(light));
        this.lights = [];

        // –û—Å–Ω–æ–≤–Ω–æ–π –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–≤–µ—Ç (—Å–æ–ª–Ω—Ü–µ)
        const sunLight = new THREE.DirectionalLight(0xfff4e6, 1.5);
        sunLight.position.set(500, 1000, 500);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 2000;
        sunLight.shadow.camera.left = -1000;
        sunLight.shadow.camera.right = 1000;
        sunLight.shadow.camera.top = 1000;
        sunLight.shadow.camera.bottom = -1000;
        this.scene.add(sunLight);
        this.lights.push(sunLight);

        // –ó–∞–ø–æ–ª–Ω—è—é—â–∏–π —Å–≤–µ—Ç
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        this.scene.add(ambientLight);
        this.lights.push(ambientLight);

        // Hemisphere light –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –æ—Å–≤–µ—â–µ–Ω–∏—è
        const hemisphereLight = new THREE.HemisphereLight(
            0x87CEEB, // –Ω–µ–±–æ
            0x3d2814, // –∑–µ–º–ª—è
            0.6
        );
        this.scene.add(hemisphereLight);
        this.lights.push(hemisphereLight);

        console.log('–û—Å–≤–µ—â–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ');
    }

    createHighResolutionTerrain(heightmap, width, height, heightScale = 80, lod = 2) {
        if (!this.isInitialized) {
            console.error('Three.js –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
            return;
        }

        try {
            console.log('–°–æ–∑–¥–∞–Ω–∏–µ –≤—ã—Å–æ–∫–æ—Ä–∞–∑—Ä–µ—à–µ–Ω–Ω–æ–≥–æ —Ç–µ—Ä—Ä–µ–π–Ω–∞...', { 
                width, height, heightScale, lod,
                totalVertices: width * height
            });

            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π —Ç–µ—Ä—Ä–µ–π–Ω
            if (this.terrain) {
                this.scene.remove(this.terrain);
                if (this.terrain.geometry) this.terrain.geometry.dispose();
                if (this.terrain.material) this.terrain.material.dispose();
            }

            // –ü—Ä–∏–º–µ–Ω—è–µ–º Level of Detail (LOD)
            const lodFactor = parseInt(lod) || 2;
            const segmentsX = Math.floor((width - 1) / lodFactor);
            const segmentsY = Math.floor((height - 1) / lodFactor);
            
            console.log(`LOD: ${lodFactor}x, —Å–µ–≥–º–µ–Ω—Ç—ã: ${segmentsX}x${segmentsY}`);

            // –°–æ–∑–¥–∞–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é —Å LOD
            const geometry = new THREE.PlaneGeometry(width, height, segmentsX, segmentsY);
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—ã—Å–æ—Ç—ã —Å –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–µ–π –¥–ª—è LOD
            this.applyHeightsWithLOD(geometry, heightmap, width, height, heightScale, lodFactor);

            geometry.computeVertexNormals();

            // –°–æ–∑–¥–∞–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª
            const material = this.createHighQualityMaterial(geometry, heightScale);

            // –°–æ–∑–¥–∞–µ–º –º–µ—à
            this.terrain = new THREE.Mesh(geometry, material);
            this.terrain.rotation.x = -Math.PI / 2;
            this.terrain.receiveShadow = true;
            this.terrain.castShadow = true;
            this.terrain.position.set(-width/2, 0, -height/2);

            this.scene.add(this.terrain);

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            this.updateGeometryStats(geometry);

            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É
            this.fitCameraToTerrain(width, height, heightScale);

            console.log('–í—ã—Å–æ–∫–æ—Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–π —Ç–µ—Ä—Ä–µ–π–Ω —Å–æ–∑–¥–∞–Ω');

        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ—Ä—Ä–µ–π–Ω–∞:', error);
        }
    }

    applyHeightsWithLOD(geometry, heightmap, width, height, heightScale, lodFactor) {
        const vertices = geometry.attributes.position.array;
        const segmentsX = Math.floor((width - 1) / lodFactor);
        const segmentsY = Math.floor((height - 1) / lodFactor);
        
        let vertexIndex = 0;
        
        for (let y = 0; y <= segmentsY; y++) {
            for (let x = 0; x <= segmentsX; x++) {
                // –í—ã—á–∏—Å–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–µ
                const origX = Math.min(x * lodFactor, width - 1);
                const origY = Math.min(y * lodFactor, height - 1);
                
                // –ë–∏–ª–∏–Ω–µ–π–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
                const heightValue = this.bilinearInterpolate(heightmap, width, height, origX, origY);
                
                vertices[vertexIndex * 3 + 2] = heightValue * heightScale;
                vertexIndex++;
            }
        }
    }

    bilinearInterpolate(heightmap, width, height, x, y) {
        const x1 = Math.floor(x);
        const x2 = Math.min(x1 + 1, width - 1);
        const y1 = Math.floor(y);
        const y2 = Math.min(y1 + 1, height - 1);
        
        const dx = x - x1;
        const dy = y - y1;
        
        // –ó–Ω–∞—á–µ–Ω–∏—è –≤ —á–µ—Ç—ã—Ä–µ—Ö —É–≥–ª–∞—Ö
        const q11 = heightmap[y1 * width + x1];
        const q12 = heightmap[y2 * width + x1];
        const q21 = heightmap[y1 * width + x2];
        const q22 = heightmap[y2 * width + x2];
        
        // –ë–∏–ª–∏–Ω–µ–π–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è
        const r1 = q11 * (1 - dx) + q21 * dx;
        const r2 = q12 * (1 - dx) + q22 * dx;
        
        return r1 * (1 - dy) + r2 * dy;
    }

    createHighQualityMaterial(geometry, heightScale) {
        // –°–æ–∑–¥–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—ã–µ —Ü–≤–µ—Ç–∞ –≤–µ—Ä—à–∏–Ω
        this.addDetailedVertexColors(geometry, heightScale);

        return new THREE.MeshStandardMaterial({
            vertexColors: true,
            roughness: 0.8,
            metalness: 0.2,
            flatShading: false,
            side: THREE.DoubleSide
        });
    }

    addDetailedVertexColors(geometry, heightScale, waterLevel = 0.15) {
        const colors = [];
        const position = geometry.attributes.position;
        const color = new THREE.Color();
        
        for (let i = 0; i < position.count; i++) {
            const z = position.getZ(i);
            const normalizedHeight = z / heightScale;
            
            // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Ü–≤–µ—Ç–∞ —Å —É—á–µ—Ç–æ–º —É—Ä–æ–≤–Ω—è –≤–æ–¥—ã
            const adjustedHeight = Math.max(0, normalizedHeight - waterLevel) / (1 - waterLevel);
            
            if (normalizedHeight < waterLevel) {
                // –í–æ–¥–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏
                const intensity = normalizedHeight / waterLevel;
                if (intensity < 0.3) {
                    // –ì–ª—É–±–æ–∫–æ–≤–æ–¥–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏ - —Ç–µ–º–Ω–æ-—Å–∏–Ω–∏–π
                    color.setRGB(0.0, 0.0, 0.1 + intensity * 0.3);
                } else if (intensity < 0.7) {
                    // –°—Ä–µ–¥–Ω—è—è –≥–ª—É–±–∏–Ω–∞ - —Å–∏–Ω–∏–π
                    color.setRGB(0.0, 0.2, 0.5 + intensity * 0.3);
                } else {
                    // –ú–µ–ª–∫–æ–≤–æ–¥—å–µ - –±–∏—Ä—é–∑–æ–≤—ã–π
                    color.setRGB(0.1, 0.4 + intensity * 0.3, 0.7 + intensity * 0.2);
                }
            } else if (adjustedHeight < 0.1) {
                // –ü–ª—è–∂ - –ø–µ—Å–æ—á–Ω—ã–µ —Ü–≤–µ—Ç–∞
                const intensity = adjustedHeight / 0.1;
                color.setRGB(0.9, 0.8 + intensity * 0.1, 0.4);
            } else if (adjustedHeight < 0.4) {
                // –†–∞–≤–Ω–∏–Ω—ã - –∑–µ–ª–µ–Ω—ã–µ —Ç–æ–Ω–∞
                const intensity = adjustedHeight / 0.4;
                color.setRGB(0.1, 0.4 + intensity * 0.4, 0.1);
            } else if (adjustedHeight < 0.7) {
                // –•–æ–ª–º—ã - –∑–µ–º–ª—è–Ω—ã–µ —Ç–æ–Ω–∞
                const intensity = (adjustedHeight - 0.4) / 0.3;
                color.setRGB(0.3 + intensity * 0.3, 0.2 + intensity * 0.2, 0.1);
            } else if (adjustedHeight < 0.9) {
                // –ì–æ—Ä—ã - —Å–µ—Ä—ã–µ —Ç–æ–Ω–∞
                const intensity = (adjustedHeight - 0.7) / 0.2;
                const gray = 0.3 + intensity * 0.4;
                color.setRGB(gray, gray, gray);
            } else {
                // –ó–∞—Å–Ω–µ–∂–µ–Ω–Ω—ã–µ –≤–µ—Ä—à–∏–Ω—ã - –±–µ–ª—ã–µ
                const intensity = (adjustedHeight - 0.9) / 0.1;
                const white = 0.6 + intensity * 0.4;
                color.setRGB(white, white, white);
            }
            
            colors.push(color.r, color.g, color.b);
        }
        
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    }

    updateExistingTerrain(heightmap, heightScale, waterLevel = 0.15) {
        if (!this.terrain || !heightmap) return;

        const geometry = this.terrain.geometry;
        const vertices = geometry.attributes.position.array;
        const size = Math.sqrt(heightmap.length);

        // –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã—Å–æ—Ç—ã
        for (let i = 0, j = 0; i < vertices.length; i += 3, j++) {
            if (j < heightmap.length) {
                vertices[i + 2] = heightmap[j] * heightScale;
            }
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals();
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç–∞ —Å —É—á–µ—Ç–æ–º —É—Ä–æ–≤–Ω—è –≤–æ–¥—ã
        this.addDetailedVertexColors(geometry, heightScale, waterLevel);
        geometry.attributes.color.needsUpdate = true;

        console.log('–¢–µ—Ä—Ä–µ–π–Ω –æ–±–Ω–æ–≤–ª–µ–Ω –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏');
    }

    setViewMode(mode) {
        if (!this.terrain) return;

        const material = this.terrain.material;
        
        if (mode === 'wireframe') {
            material.wireframe = true;
            material.needsUpdate = true;
        } else {
            material.wireframe = false;
            material.needsUpdate = true;
        }
    }

    getTerrainIntersection(mouseX, mouseY) {
        if (!this.terrain) return null;

        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º—ã—à–∏
        this.mouse.x = mouseX;
        this.mouse.y = mouseY;

        // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–π–∫–∞—Å—Ç–µ—Ä
        this.raycaster.setFromCamera(this.mouse, this.camera);

        // –ò—â–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        const intersects = this.raycaster.intersectObject(this.terrain);
        
        return intersects.length > 0 ? intersects[0] : null;
    }

    getHeightAtWorldPosition(worldPos) {
        if (!this.terrain) return 0;

        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ª–æ–∫–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–µ—Ä—Ä–µ–π–Ω–∞
        const localPos = worldPos.clone();
        this.terrain.worldToLocal(localPos);

        return localPos.y; // –í Three.js Y - —ç—Ç–æ –≤—ã—Å–æ—Ç–∞ –ø–æ—Å–ª–µ rotation.x = -PI/2
    }

    fitCameraToTerrain(width, height, heightScale) {
        const maxDim = Math.max(width, height, heightScale);
        const distance = maxDim * 1.2;
        
        this.camera.position.set(distance, distance * 0.7, distance);
        this.controls.target.set(0, heightScale * 0.2, 0);
        this.controls.update();

        console.log('–ö–∞–º–µ—Ä–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞ –Ω–∞ –±–æ–ª—å—à–æ–π —Ç–µ—Ä—Ä–µ–π–Ω', { distance });
    }

    updateGeometryStats(geometry) {
        const vertexCount = geometry.attributes.position.count;
        const polyCount = vertexCount / 3;
        
        if (document.getElementById('vertexCount')) {
            document.getElementById('vertexCount').textContent = `–í–µ—Ä—à–∏–Ω—ã: ${vertexCount.toLocaleString()}`;
        }
        if (document.getElementById('polyCount')) {
            document.getElementById('polyCount').textContent = `–ü–æ–ª–∏–≥–æ–Ω—ã: ${Math.floor(polyCount).toLocaleString()}`;
        }
    }

    showLoading(show, text = "–ó–∞–≥—Ä—É–∑–∫–∞...", progress = 0) {
        const loading = document.getElementById('loading');
        if (loading) {
            loading.style.display = show ? 'flex' : 'none';
            const textEl = loading.querySelector('.loading-text');
            const progressEl = document.getElementById('loadingProgress');
            
            if (textEl) textEl.textContent = text;
            if (progressEl) progressEl.textContent = `${Math.round(progress)}%`;
        }
    }

    takeScreenshot() {
        if (!this.renderer) return;

        this.renderer.domElement.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `terrain_screenshot_${Date.now()}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 'image/png');
    }

    animate() {
        if (!this.isInitialized) return;
        
        requestAnimationFrame(() => this.animate());
        
        if (this.controls) {
            this.controls.update();
        }
        
        this.renderer.render(this.scene, this.camera);
    }

    onResize() {
        if (!this.isInitialized) return;
        
        this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    }

    dispose() {
        if (this.terrain) {
            this.scene.remove(this.terrain);
            if (this.terrain.geometry) this.terrain.geometry.dispose();
            if (this.terrain.material) this.terrain.material.dispose();
        }

        this.lights.forEach(light => this.scene.remove(light));
        this.lights = [];

        if (this.renderer) {
            this.renderer.dispose();
        }

        this.isInitialized = false;
    }
}

//perlin.js
class PerlinNoise {
    constructor(seed = 12345) {
        this.seed = seed;
        this.permutation = new Array(512);
        this.init();
    }

    init() {
        const p = new Array(256);
        for (let i = 0; i < 256; i++) {
            p[i] = i;
        }

        let random = this.mulberry32(this.seed);
        for (let i = 255; i > 0; i--) {
            const j = Math.floor(random() * (i + 1));
            [p[i], p[j]] = [p[j], p[i]];
        }

        for (let i = 0; i < 512; i++) {
            this.permutation[i] = p[i & 255];
        }
    }

    mulberry32(seed) {
        return function() {
            seed |= 0;
            seed = seed + 0x6D2B79F5 | 0;
            let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
            t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
    }

    fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }

    lerp(t, a, b) {
        return a + t * (b - a);
    }

    grad(hash, x, y, z) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    }

    noise(x, y = 0, z = 0) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        const Z = Math.floor(z) & 255;

        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);

        const u = this.fade(x);
        const v = this.fade(y);
        const w = this.fade(z);

        const A = this.permutation[X] + Y;
        const AA = this.permutation[A] + Z;
        const AB = this.permutation[A + 1] + Z;
        const B = this.permutation[X + 1] + Y;
        const BA = this.permutation[B] + Z;
        const BB = this.permutation[B + 1] + Z;

        return this.lerp(w, 
            this.lerp(v, 
                this.lerp(u, 
                    this.grad(this.permutation[AA], x, y, z),
                    this.grad(this.permutation[BA], x - 1, y, z)
                ),
                this.lerp(u,
                    this.grad(this.permutation[AB], x, y - 1, z),
                    this.grad(this.permutation[BB], x - 1, y - 1, z)
                )
            ),
            this.lerp(v,
                this.lerp(u,
                    this.grad(this.permutation[AA + 1], x, y, z - 1),
                    this.grad(this.permutation[BA + 1], x - 1, y, z - 1)
                ),
                this.lerp(u,
                    this.grad(this.permutation[AB + 1], x, y - 1, z - 1),
                    this.grad(this.permutation[BB + 1], x - 1, y - 1, z - 1)
                )
            )
        );
    }

    fractalNoise(x, y, octaves, persistence, lacunarity) {
        let value = 0;
        let amplitude = 1;
        let frequency = 1;
        let maxValue = 0;

        for (let i = 0; i < octaves; i++) {
            value += this.noise(x * frequency, y * frequency) * amplitude;
            maxValue += amplitude;
            amplitude *= persistence;
            frequency *= lacunarity;
        }

        return value / maxValue;
    }

    generateHighResolutionHeightmap(width, height, scale, octaves, persistence, lacunarity) {
        const heightmap = new Float32Array(width * height);
        
        console.log('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —à—É–º–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏:', { scale, octaves, persistence, lacunarity });
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const nx = (x / width - 0.5) * scale;
                const ny = (y / height - 0.5) * scale;
                
                // –û—Å–Ω–æ–≤–Ω–æ–π —à—É–º
                let elevation = this.fractalNoise(nx, ny, octaves, persistence, lacunarity);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—é —Å –¥—Ä—É–≥–æ–π —á–∞—Å—Ç–æ—Ç–æ–π –¥–ª—è –±–æ–ª—å—à–µ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
                if (octaves > 1) {
                    const detail = this.noise(nx * 2.5, ny * 2.5) * 0.15;
                    elevation += detail;
                }
                
                // –ü—Ä–∏–≤–æ–¥–∏–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É [0, 1]
                elevation = (elevation + 1) * 0.5;
                
                heightmap[y * width + x] = elevation;
            }
        }

        return heightmap;
    }
}

//diamondSquare.js
class DiamondSquare {
    constructor(seed = 12345) {
        this.seed = seed;
        this.random = this.mulberry32(seed);
    }

    mulberry32(seed) {
        return function() {
            seed |= 0;
            seed = seed + 0x6D2B79F5 | 0;
            let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
            t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
    }

    generate(size, roughness = 0.5, initialHeight = 0.3) {
        // –†–∞–∑–º–µ—Ä –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å—Ç–µ–ø–µ–Ω—å—é –¥–≤–æ–π–∫–∏ + 1 
        const power = Math.ceil(Math.log2(size - 1));
        const actualSize = Math.pow(2, power) + 1;
        
        console.log(`Diamond-Square: –≥–µ–Ω–µ—Ä–∞—Ü–∏—è ${actualSize}x${actualSize}, —à–µ—Ä–æ—Ö–æ–≤–∞—Ç–æ—Å—Ç—å: ${roughness}`);

        const map = new Float32Array(actualSize * actualSize);
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —É–≥–ª—ã —Å –º–µ–Ω—å—à–∏–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –¥–ª—è –±–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–≥–æ —Å—Ç–∞—Ä—Ç–∞
        this.initCorners(map, actualSize, initialHeight);
        
        // –í—ã–ø–æ–ª–Ω—è–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ–º
        this.diamondSquareAlgorithm(map, actualSize, roughness);
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤
        this.applyPostSmoothing(map, actualSize, 0.3);
        
        return map;
    }

    initCorners(map, size, initialHeight) {
        // –ë–æ–ª–µ–µ –ø–ª–∞–≤–Ω—ã–µ –Ω–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        map[0] = (this.random() * 0.5 + 0.25) * initialHeight;
        map[size - 1] = (this.random() * 0.5 + 0.25) * initialHeight;
        map[size * (size - 1)] = (this.random() * 0.5 + 0.25) * initialHeight;
        map[size * size - 1] = (this.random() * 0.5 + 0.25) * initialHeight;
    }

    diamondSquareAlgorithm(map, size, roughness) {
        let step = size - 1;
        let heightRange = 0.8; // –£–º–µ–Ω—å—à–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω

        while (step > 1) {
            const halfStep = Math.floor(step / 2);
            
            // Diamond step —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º —Å–ª—É—á–∞–π–Ω—ã–º —Å–º–µ—â–µ–Ω–∏–µ–º
            this.diamondStep(map, size, step, halfStep, heightRange, roughness);
            
            // Square step —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º —Å–ª—É—á–∞–π–Ω—ã–º —Å–º–µ—â–µ–Ω–∏–µ–º
            this.squareStep(map, size, step, halfStep, heightRange, roughness);
            
            // –ë–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–µ —É–º–µ–Ω—å—à–µ–Ω–∏–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
            heightRange *= Math.pow(2, -roughness * 1.2);
            step = halfStep;
        }
    }

    diamondStep(map, size, step, halfStep, heightRange, roughness) {
        for (let y = halfStep; y < size; y += step) {
            for (let x = halfStep; x < size; x += step) {
                const avg = this.getSquareAverage(map, size, x, y, halfStep);
                // –ë–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–µ —Å–ª—É—á–∞–π–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ
                const randomOffset = (this.random() - 0.5) * heightRange * this.getSmoothingFactor(x, y, size);
                const value = avg + randomOffset;
                map[y * size + x] = this.clamp(value, 0, 1);
            }
        }
    }

    squareStep(map, size, step, halfStep, heightRange, roughness) {
        for (let y = 0; y < size; y += halfStep) {
            const yOffset = (y + halfStep) % step !== 0 ? 0 : halfStep;
            
            for (let x = (yOffset + halfStep) % step; x < size; x += step) {
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Ç–æ—á–∫–∏ diamond step
                if ((y % step === halfStep) && (x % step === halfStep)) continue;
                
                const avg = this.getDiamondAverage(map, size, x, y, halfStep);
                // –ë–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–µ —Å–ª—É—á–∞–π–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ
                const randomOffset = (this.random() - 0.5) * heightRange * this.getSmoothingFactor(x, y, size);
                const value = avg + randomOffset;
                map[y * size + x] = this.clamp(value, 0, 1);
            }
        }
    }

    getSmoothingFactor(x, y, size) {
        // –£–º–µ–Ω—å—à–∞–µ–º –≤–ª–∏—è–Ω–∏–µ —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏ near –∫—Ä–∞–µ–≤ –¥–ª—è –±–æ–ª–µ–µ –ø–ª–∞–≤–Ω—ã—Ö –≥—Ä–∞–Ω–∏—Ü
        const edgeDistance = Math.min(
            x / size,
            y / size,
            (size - 1 - x) / size,
            (size - 1 - y) / size
        );
        
        return Math.min(1.0, edgeDistance * 2 + 0.3);
    }

    getSquareAverage(map, size, x, y, halfStep) {
        const topLeft = map[(y - halfStep) * size + (x - halfStep)];
        const topRight = map[(y - halfStep) * size + (x + halfStep)];
        const bottomLeft = map[(y + halfStep) * size + (x - halfStep)];
        const bottomRight = map[(y + halfStep) * size + (x + halfStep)];
        
        return (topLeft + topRight + bottomLeft + bottomRight) / 4;
    }

    getDiamondAverage(map, size, x, y, halfStep) {
        let sum = 0;
        let count = 0;

        // –í–µ—Ä—Ö–Ω–∏–π —Å–æ—Å–µ–¥
        if (y - halfStep >= 0) {
            sum += map[(y - halfStep) * size + x];
            count++;
        }

        // –ü—Ä–∞–≤—ã–π —Å–æ—Å–µ–¥
        if (x + halfStep < size) {
            sum += map[y * size + (x + halfStep)];
            count++;
        }

        // –ù–∏–∂–Ω–∏–π —Å–æ—Å–µ–¥
        if (y + halfStep < size) {
            sum += map[(y + halfStep) * size + x];
            count++;
        }

        // –õ–µ–≤—ã–π —Å–æ—Å–µ–¥
        if (x - halfStep >= 0) {
            sum += map[y * size + (x - halfStep)];
            count++;
        }

        return count > 0 ? sum / count : 0;
    }

    applyPostSmoothing(map, size, strength) {
        if (strength <= 0) return;

        const temp = new Float32Array(map);
        const kernel = [0.05, 0.1, 0.05, 0.1, 0.4, 0.1, 0.05, 0.1, 0.05];
        
        for (let y = 1; y < size - 1; y++) {
            for (let x = 1; x < size - 1; x++) {
                let sum = 0;
                let kernelIndex = 0;
                
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        sum += temp[ny * size + nx] * kernel[kernelIndex++];
                    }
                }
                
                map[y * size + x] = map[y * size + x] * (1 - strength) + sum * strength;
            }
        }
    }

    clamp(value, min = 0, max = 1) {
        return Math.max(min, Math.min(max, value));
    }

    // –£–ª—É—á—à–µ–Ω–Ω—ã–π –≥–∏–±—Ä–∏–¥–Ω—ã–π –º–µ—Ç–æ–¥
    generateHybrid(size, perlinNoise, perlinScale = 80, perlinWeight = 0.4, roughness = 0.5) {
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –±–∞–∑–æ–≤—ã–π –ª–∞–Ω–¥—à–∞—Ñ—Ç Diamond-Square —Å –º–µ–Ω—å—à–µ–π —à–µ—Ä–æ—Ö–æ–≤–∞—Ç–æ—Å—Ç—å—é
        const dsMap = this.generate(size, roughness * 0.7, 0.2);
        
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–µ—Ç–∞–ª–∏ Perlin Noise —Å –±–æ–ª—å—à–∏–º –º–∞—Å—à—Ç–∞–±–æ–º
        const perlinDetails = new Float32Array(size * size);
        
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const nx = (x / size - 0.5) * perlinScale;
                const ny = (y / size - 0.5) * perlinScale;
                
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—Ä–∞–∫—Ç–∞–ª—å–Ω—ã–π —à—É–º –¥–ª—è –±–æ–ª–µ–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –¥–µ—Ç–∞–ª–µ–π
                let noise = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxAmplitude = 0;
                
                for (let i = 0; i < 3; i++) {
                    noise += perlinNoise.noise(nx * frequency, ny * frequency) * amplitude;
                    maxAmplitude += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                
                noise = (noise / maxAmplitude + 1) * 0.5;
                perlinDetails[y * size + x] = noise;
            }
        }

        // –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Å–º–µ—à–∏–≤–∞–Ω–∏–µ
        const hybridMap = new Float32Array(size * size);
        for (let i = 0; i < hybridMap.length; i++) {
            // –ù–µ–ª–∏–Ω–µ–π–Ω–æ–µ —Å–º–µ—à–∏–≤–∞–Ω–∏–µ –¥–ª—è –±–æ–ª–µ–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            const base = dsMap[i];
            const detail = perlinDetails[i];
            const mixed = base + (detail - 0.5) * perlinWeight * base;
            hybridMap[i] = this.clamp(mixed);
        }

        return hybridMap;
    }
}

//erosion.js
class HydraulicErosion {
    constructor() {
        this.waterAmount = 0.01;
        this.sedimentCapacityFactor = 4;
        this.minSedimentCapacity = 0.01;
        this.evaporateSpeed = 0.01;
        this.gravity = 4;
        this.maxDropletLifetime = 30;
    }

    applyErosion(heightmap, width, height, iterations, intensity = 1.0) {
        if (iterations <= 0) return heightmap;
        
        const newHeightmap = new Float32Array(heightmap);

        for (let i = 0; i < iterations; i++) {
            this.simulateDroplet(newHeightmap, width, height, intensity);
        }

        return newHeightmap;
    }

    simulateDroplet(heightmap, width, height, intensity) {
        let posX = Math.random() * (width - 1);
        let posY = Math.random() * (height - 1);
        
        let dirX = 0;
        let dirY = 0;
        let speed = 1;
        let water = 1;
        let sediment = 0;

        for (let lifetime = 0; lifetime < this.maxDropletLifetime; lifetime++) {
            const nodeX = Math.floor(posX);
            const nodeY = Math.floor(posY);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã
            if (nodeX < 0 || nodeX >= width - 1 || nodeY < 0 || nodeY >= height - 1) {
                break;
            }

            // –í—ã—á–∏—Å–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç
            const gradient = this.calculateGradient(heightmap, width, height, posX, posY);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            dirX = (dirX * 0.5 - gradient.x * 0.5);
            dirY = (dirY * 0.5 - gradient.y * 0.5);
            
            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            const len = Math.sqrt(dirX * dirX + dirY * dirY);
            if (len > 0) {
                dirX /= len;
                dirY /= len;
            }

            const newPosX = posX + dirX;
            const newPosY = posY + dirY;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã
            if (newPosX < 0 || newPosX >= width - 1 || newPosY < 0 || newPosY >= height - 1) {
                break;
            }

            // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–Ω–∏—Ü—É –≤—ã—Å–æ—Ç
            const newHeight = this.getHeight(heightmap, width, newPosX, newPosY);
            const currentHeight = this.getHeight(heightmap, width, posX, posY);
            const heightDiff = newHeight - currentHeight;

            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ –¥–≤–∏–∂–µ–º—Å—è –≤–≤–µ—Ä—Ö
            if (heightDiff > 0) {
                // –û—Ç–∫–ª–∞–¥—ã–≤–∞–µ–º –æ—Å–∞–¥–æ–∫ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –≤–≤–µ—Ä—Ö
                const depositAmount = Math.min(sediment, heightDiff);
                this.addHeight(heightmap, width, posX, posY, depositAmount);
                sediment -= depositAmount;
            } else {
                // –≠—Ä–æ–¥–∏—Ä—É–µ–º –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –≤–Ω–∏–∑
                const erosionAmount = Math.min(-heightDiff * 0.1, 0.01) * intensity;
                sediment += erosionAmount;
                this.addHeight(heightmap, width, posX, posY, -erosionAmount);
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –∏ –≤–æ–¥—É
            speed = Math.max(0.1, speed + heightDiff * this.gravity);
            water *= (1 - this.evaporateSpeed);

            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
            posX = newPosX;
            posY = newPosY;

            // –ü—Ä–µ—Ä—ã–≤–∞–µ–º –µ—Å–ª–∏ —Å–ª–∏—à–∫–æ–º –º–∞–ª–æ –≤–æ–¥—ã
            if (water < 0.001) break;
        }
    }

    calculateGradient(heightmap, width, height, posX, posY) {
        const coordX = Math.floor(posX);
        const coordY = Math.floor(posY);
        
        const heightL = this.getHeight(heightmap, width, coordX - 1, coordY);
        const heightR = this.getHeight(heightmap, width, coordX + 1, coordY);
        const heightD = this.getHeight(heightmap, width, coordX, coordY - 1);
        const heightU = this.getHeight(heightmap, width, coordX, coordY + 1);
        
        return {
            x: (heightR - heightL) * 0.5,
            y: (heightU - heightD) * 0.5
        };
    }

    getHeight(heightmap, width, x, y) {
        const coordX = Math.max(0, Math.min(width - 1, Math.floor(x)));
        const coordY = Math.max(0, Math.min(width - 1, Math.floor(y)));
        return heightmap[coordY * width + coordX];
    }

    addHeight(heightmap, width, x, y, delta) {
        const coordX = Math.max(0, Math.min(width - 1, Math.floor(x)));
        const coordY = Math.max(0, Math.min(width - 1, Math.floor(y)));
        const newHeight = heightmap[coordY * width + coordX] + delta;
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤—ã—Å–æ—Ç—É —Ä–∞–∑—É–º–Ω—ã–º–∏ –ø—Ä–µ–¥–µ–ª–∞–º–∏
        heightmap[coordY * width + coordX] = Math.max(-1, Math.min(2, newHeight));
    }
}

//main.js
class TerrainGenerator {
    constructor() {
        this.perlin = new PerlinNoise();
        this.diamondSquare = new DiamondSquare();
        this.erosion = new HydraulicErosion();
        this.threeRenderer = null;
        this.currentHeightmap = null;
        this.isGenerating = false;
        this.realtimeUpdate = false;
        this.updateTimeout = null;
        this.currentSeed = 12345;
        this.currentSize = 257;
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                this.initialize();
            });
        } else {
            this.initialize();
        }
    }

    initialize() {
        this.initializeEventListeners();
        this.initializeThreeJS();
        
        window.addEventListener('resize', () => {
            if (this.threeRenderer) {
                this.threeRenderer.onResize();
            }
        });
    }

    async initializeThreeJS() {
        try {
            console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞...');
            
            const container = document.getElementById('threeContainer');
            if (!container) {
                console.error('–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä threeContainer –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ DOM');
                return;
            }
            
            this.threeRenderer = new ThreeRenderer('threeContainer');
            
            setTimeout(() => {
                this.generateTerrain();
            }, 1000);
            
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ThreeRenderer:', error);
        }
    }

    initializeEventListeners() {
        console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π...');
        
        this.addEventListenerSafe('generate', 'click', () => {
            this.generateTerrain();
        });

        this.addEventListenerSafe('randomSeed', 'click', () => {
            this.currentSeed = Math.floor(Math.random() * 100000);
            const seedInput = document.getElementById('seed');
            if (seedInput) seedInput.value = this.currentSeed;
            this.generateTerrain();
        });

        this.setupRealtimeControls();
        
        this.addEventListenerSafe('export', 'click', () => {
            this.exportHeightmap();
        });

        this.addEventListenerSafe('screenshot', 'click', () => {
            this.takeScreenshot();
        });

        this.addEventListenerSafe('viewSolid', 'click', () => {
            this.setViewMode('solid');
        });

        this.addEventListenerSafe('viewWireframe', 'click', () => {
            this.setViewMode('wireframe');
        });

        this.addEventListenerSafe('algorithm', 'change', (e) => {
            this.updateAlgorithmInfo(e.target.value);
            this.scheduleRegeneration();
        });

        console.log('–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã');
    }

    updateAlgorithmInfo(algorithm) {
        const infoMap = {
            'perlin': 'Perlin Noise',
            'diamond': 'Diamond-Square', 
            'hybrid': '–ì–∏–±—Ä–∏–¥–Ω—ã–π'
        };
        
        this.updateElementText('algorithmInfo', `–ê–ª–≥–æ—Ä–∏—Ç–º: ${infoMap[algorithm] || algorithm}`);
    }

    addEventListenerSafe(elementId, event, handler) {
        const element = document.getElementById(elementId);
        if (element) {
            element.addEventListener(event, handler);
        } else {
            console.warn(`–≠–ª–µ–º–µ–Ω—Ç —Å ID '${elementId}' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ DOM`);
        }
    }

    setupRealtimeControls() {
        console.log('–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª–æ–≤ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏...');
        
        const regenerationParams = [
            'scale', 'octaves', 'roughness', 'erosionIterations', 'smoothing',
            'dsRoughness', 'hybridWeight'
        ];
        
        const applyParams = ['heightScale', 'waterLevel', 'colorIntensity'];

        regenerationParams.forEach(param => {
            const element = document.getElementById(param);
            if (element) {
                element.addEventListener('input', (e) => {
                    this.updateParameterValue(param, e.target.value);
                    this.scheduleRegeneration();
                });
            }
        });

        applyParams.forEach(param => {
            const element = document.getElementById(param);
            if (element) {
                element.addEventListener('input', (e) => {
                    this.updateParameterValue(param, e.target.value);
                    this.scheduleRealtimeUpdate();
                });
            }
        });

        this.addEventListenerSafe('size', 'change', (e) => {
            this.currentSize = parseInt(e.target.value);
            this.generateTerrain();
        });

        this.addEventListenerSafe('seed', 'change', (e) => {
            this.currentSeed = parseInt(e.target.value);
            this.generateTerrain();
        });
    }

    updateParameterValue(param, value) {
        const valueElements = {
            'scale': 'scaleValue',
            'octaves': 'octavesValue',
            'roughness': 'roughnessValue',
            'heightScale': 'heightScaleValue',
            'erosionIterations': 'erosionValue',
            'waterLevel': 'waterLevelValue',
            'colorIntensity': 'colorIntensityValue',
            'smoothing': 'smoothingValue',
            'dsRoughness': 'dsRoughnessValue',
            'hybridWeight': 'hybridWeightValue'
        };

        const valueElementId = valueElements[param];
        if (!valueElementId) {
            console.warn(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä: ${param}`);
            return;
        }

        const valueElement = document.getElementById(valueElementId);
        if (valueElement) {
            if (param === 'roughness' || param === 'dsRoughness') {
                valueElement.textContent = (value / 100).toFixed(2);
            } else if (param === 'waterLevel' || param === 'colorIntensity' || param === 'hybridWeight') {
                valueElement.textContent = value + '%';
            } else {
                valueElement.textContent = value;
            }
        }
    }

    scheduleRegeneration() {
        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
        }

        this.updateTimeout = setTimeout(() => {
            this.regenerateFromCurrentParameters();
        }, 800);
    }

    scheduleRealtimeUpdate() {
        if (this.updateTimeout) {
            clearTimeout(this.updateTimeout);
        }

        this.updateTimeout = setTimeout(() => {
            this.applyRealtimeChanges();
        }, 300);
    }

    regenerateFromCurrentParameters() {
        if (this.isGenerating) {
            return;
        }

        console.log('–ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Ä—Ä–µ–π–Ω–∞ —Å –Ω–æ–≤—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏...');
        this.generateTerrain(false);
    }

    applyRealtimeChanges() {
        if (!this.currentHeightmap || this.isGenerating) {
            return;
        }

        console.log('–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏...');
        
        const heightScale = this.getNumberValue('heightScale', 50);
        const waterLevel = this.getNumberValue('waterLevel', 15) / 100;
        
        if (this.threeRenderer && this.threeRenderer.isInitialized) {
            this.threeRenderer.updateExistingTerrain(this.currentHeightmap, heightScale, waterLevel);
        }

        this.updateStats(this.currentHeightmap, 0);
    }

    getNumberValue(elementId, defaultValue) {
        const element = document.getElementById(elementId);
        return element ? parseInt(element.value) || defaultValue : defaultValue;
    }

    async generateTerrain(showProgress = true) {
        if (this.isGenerating) {
            console.log('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è...');
            return;
        }

        this.isGenerating = true;
        const startTime = performance.now();
        
        try {
            const seed = this.currentSeed;
            const size = this.currentSize;
            const algorithm = document.getElementById('algorithm')?.value || 'hybrid';
            const scale = this.getNumberValue('scale', 120);
            const octaves = this.getNumberValue('octaves', 4);
            const roughness = this.getNumberValue('roughness', 40) / 100;
            const dsRoughness = this.getNumberValue('dsRoughness', 50) / 100;
            const hybridWeight = this.getNumberValue('hybridWeight', 40) / 100;
            const heightScale = this.getNumberValue('heightScale', 50);
            const erosionIterations = this.getNumberValue('erosionIterations', 3000);
            const smoothing = this.getNumberValue('smoothing', 30);

            console.log('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Ä—Ä–µ–π–Ω–∞:', { 
                algorithm, seed, size, scale, octaves, roughness, 
                dsRoughness, hybridWeight, heightScale, erosionIterations, smoothing
            });

            if (showProgress) {
                this.updateProgress(10, "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—ã—Å–æ—Ç...");
            }

            let heightmap;

            switch (algorithm) {
                case 'perlin':
                    heightmap = this.generatePerlinHeightmap(size, scale, octaves, roughness);
                    break;
                    
                case 'diamond':
                    heightmap = this.generateDiamondSquareHeightmap(size, dsRoughness);
                    break;
                    
                case 'hybrid':
                default:
                    heightmap = this.generateHybridHeightmap(size, scale, octaves, roughness, dsRoughness, hybridWeight);
                    break;
            }

            if (showProgress) {
                this.updateProgress(40, "–ë–∞–∑–æ–≤—ã–π —Ä–µ–ª—å–µ—Ñ —Å–æ–∑–¥–∞–Ω");
            }

            if (smoothing > 0) {
                if (showProgress) {
                    this.updateProgress(50, "–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è...");
                }
                heightmap = this.applyAdvancedSmoothing(heightmap, size, smoothing / 100);
            }

            if (erosionIterations > 0) {
                if (showProgress) {
                    this.updateProgress(60, "–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —ç—Ä–æ–∑–∏–∏...");
                }
                const limitedErosion = Math.min(erosionIterations, 4000);
                heightmap = this.erosion.applyErosion(
                    heightmap, size, size, limitedErosion, 0.4
                );
            }

            if (smoothing > 0) {
                heightmap = this.applyLightSmoothing(heightmap, size, 0.1);
            }

            if (showProgress) {
                this.updateProgress(80, "–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤—ã—Å–æ—Ç...");
            }

            this.normalizeHeightmap(heightmap);

            if (showProgress) {
                this.updateProgress(90, "–°–æ–∑–¥–∞–Ω–∏–µ 3D —Ç–µ—Ä—Ä–µ–π–Ω–∞...");
            }

            if (this.threeRenderer && this.threeRenderer.isInitialized) {
                const lod = this.getLODValue();
                this.threeRenderer.createHighResolutionTerrain(heightmap, size, size, heightScale, lod);
            }

            this.currentHeightmap = heightmap;

            this.updateStats(heightmap, startTime);
            this.updateAlgorithmInfo(algorithm);

            if (showProgress) {
                this.updateProgress(100, "–ì–æ—Ç–æ–≤–æ!");
                setTimeout(() => {
                    if (this.threeRenderer) {
                        this.threeRenderer.showLoading(false);
                    }
                }, 500);
            }

            console.log('–¢–µ—Ä—Ä–µ–π–Ω —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ');

        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Ä—Ä–µ–π–Ω–∞:', error);
            if (showProgress && this.threeRenderer) {
                this.threeRenderer.showLoading(false);
            }
        } finally {
            this.isGenerating = false;
        }
    }

    generatePerlinHeightmap(size, scale, octaves, roughness) {
        console.log('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è Perlin Noise...');
        this.perlin = new PerlinNoise(this.currentSeed);
        return this.perlin.generateHighResolutionHeightmap(
            size, size, scale, octaves, roughness, 2.0
        );
    }

    generateDiamondSquareHeightmap(size, roughness) {
        console.log('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è Diamond-Square...');
        this.diamondSquare = new DiamondSquare(this.currentSeed);
        return this.diamondSquare.generate(size, roughness);
    }

    generateHybridHeightmap(size, scale, octaves, roughness, dsRoughness, hybridWeight) {
        console.log('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≥–∏–±—Ä–∏–¥–Ω–æ–≥–æ –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞...');
        this.perlin = new PerlinNoise(this.currentSeed);
        this.diamondSquare = new DiamondSquare(this.currentSeed);
        
        return this.diamondSquare.generateHybrid(
            size, 
            this.perlin, 
            scale, 
            hybridWeight, 
            dsRoughness
        );
    }

    applyAdvancedSmoothing(heightmap, size, strength) {
        if (strength <= 0) return heightmap;

        const smoothed = new Float32Array(heightmap);
        const kernel = [
            [1, 2, 1],
            [2, 4, 2], 
            [1, 2, 1]
        ];
        const kernelSum = 16;

        for (let pass = 0; pass < 2; pass++) {
            const source = pass === 0 ? heightmap : smoothed;
            const target = smoothed;
            
            for (let y = 1; y < size - 1; y++) {
                for (let x = 1; x < size - 1; x++) {
                    let sum = 0;
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const weight = kernel[dy + 1][dx + 1];
                            sum += source[(y + dy) * size + (x + dx)] * weight;
                        }
                    }
                    
                    const average = sum / kernelSum;
                    const current = source[y * size + x];
                    target[y * size + x] = current + (average - current) * strength;
                }
            }
        }

        return smoothed;
    }

    applyLightSmoothing(heightmap, size, strength) {
        if (strength <= 0) return heightmap;

        const smoothed = new Float32Array(heightmap);
        
        for (let y = 1; y < size - 1; y++) {
            for (let x = 1; x < size - 1; x++) {
                let sum = 0;
                let count = 0;
                
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        sum += heightmap[(y + dy) * size + (x + dx)];
                        count++;
                    }
                }
                
                const average = sum / count;
                const current = heightmap[y * size + x];
                smoothed[y * size + x] = current + (average - current) * strength;
            }
        }

        return smoothed;
    }

    getLODValue() {
        const size = this.currentSize;
        if (size <= 65) return '1';
        if (size <= 129) return '2';
        if (size <= 257) return '4';
        return '8';
    }

    setViewMode(mode) {
        if (!this.threeRenderer || !this.threeRenderer.terrain) return;

        this.threeRenderer.setViewMode(mode);
        
        const solidBtn = document.getElementById('viewSolid');
        const wireframeBtn = document.getElementById('viewWireframe');
        
        if (solidBtn && wireframeBtn) {
            if (mode === 'wireframe') {
                solidBtn.classList.remove('active');
                wireframeBtn.classList.add('active');
            } else {
                solidBtn.classList.add('active');
                wireframeBtn.classList.remove('active');
            }
        }
    }

    takeScreenshot() {
        if (this.threeRenderer) {
            this.threeRenderer.takeScreenshot();
        }
    }

    updateProgress(percent, text) {
        if (this.threeRenderer) {
            this.threeRenderer.showLoading(true, text, percent);
        }
    }

    normalizeHeightmap(heightmap) {
        if (!heightmap || heightmap.length === 0) return;

        let min = Number.MAX_VALUE;
        let max = Number.MIN_VALUE;
        
        const step = Math.max(1, Math.floor(heightmap.length / 10000));
        for (let i = 0; i < heightmap.length; i += step) {
            min = Math.min(min, heightmap[i]);
            max = Math.max(max, heightmap[i]);
        }

        if (min === max) {
            heightmap.fill(0.5);
            return;
        }
        
        const range = max - min;
        for (let i = 0; i < heightmap.length; i++) {
            heightmap[i] = (heightmap[i] - min) / range;
        }
    }

    updateStats(heightmap, startTime) {
        if (!heightmap || heightmap.length === 0) return;

        let minHeight = Number.MAX_VALUE;
        let maxHeight = Number.MIN_VALUE;
        
        const step = Math.max(1, Math.floor(heightmap.length / 5000));
        for (let i = 0; i < heightmap.length; i += step) {
            minHeight = Math.min(minHeight, heightmap[i]);
            maxHeight = Math.max(maxHeight, heightmap[i]);
        }

        const generationTime = performance.now() - startTime;

        this.updateElementText('minHeight', `–ú–∏–Ω: ${minHeight.toFixed(3)}`);
        this.updateElementText('maxHeight', `–ú–∞–∫—Å: ${maxHeight.toFixed(3)}`);
        this.updateElementText('generationTime', `–í—Ä–µ–º—è: ${(generationTime / 1000).toFixed(1)}—Å`);
        
        if (this.threeRenderer && this.threeRenderer.terrain) {
            const vertexCount = this.threeRenderer.terrain.geometry.attributes.position.count;
            this.updateElementText('vertexCount', `–í–µ—Ä—à–∏–Ω—ã: ${vertexCount.toLocaleString()}`);
        }
    }

    updateElementText(elementId, text) {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = text;
        }
    }

    exportHeightmap() {
        if (!this.currentHeightmap) {
            alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –ª–∞–Ω–¥—à–∞—Ñ—Ç!');
            return;
        }
        
        try {
            const size = Math.sqrt(this.currentHeightmap.length);
            const algorithm = document.getElementById('algorithm')?.value || 'hybrid';
            
            const data = {
                size: size,
                heightmap: Array.from(this.currentHeightmap),
                parameters: {
                    algorithm: algorithm,
                    seed: this.currentSeed,
                    scale: this.getNumberValue('scale', 120),
                    octaves: this.getNumberValue('octaves', 4),
                    roughness: this.getNumberValue('roughness', 40) / 100,
                    dsRoughness: this.getNumberValue('dsRoughness', 50) / 100,
                    hybridWeight: this.getNumberValue('hybridWeight', 40) / 100,
                    heightScale: this.getNumberValue('heightScale', 50),
                    erosionIterations: this.getNumberValue('erosionIterations', 3000),
                    smoothing: this.getNumberValue('smoothing', 30)
                },
                metadata: {
                    generated: new Date().toISOString(),
                    version: "2.0"
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { 
                type: 'application/json' 
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `terrain_${algorithm}_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('–í—ã—Å–æ—Ç—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã');
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞:', error);
            alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –¥–∞–Ω–Ω—ã—Ö');
        }
    }
}

function initializeApp() {
    try {
        console.log('–ó–∞–ø—É—Å–∫ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞ —Å Diamond-Square...');
        new TerrainGenerator();
    } catch (error) {
        console.error('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è:', error);
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}

//index.HTML
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞ - Diamond-Square + Perlin</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>3D –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞ - Diamond-Square + Perlin</h1>
            <p>–î–≤–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: –æ—Ä–≥–∞–Ω–∏—á–Ω—ã–π Diamond-Square –∏ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π Perlin Noise</p>
        </header>

        <div class="controls-panel">
            <div class="control-section">
                <h3>üé≤ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è</h3>
                <div class="control-group">
                    <label for="seed">–°–∏–¥:</label>
                    <input type="number" id="seed" value="12345">
                    <button id="randomSeed">–ù–æ–≤—ã–π —Å–∏–¥</button>
                </div>
                <div class="control-group">
                    <label for="size">–†–∞–∑–º–µ—Ä:</label>
                    <select id="size">
                        <option value="65">65x65</option>
                        <option value="129">129x129</option>
                        <option value="257" selected>257x257</option>
                        <option value="513">513x513</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="algorithm">–ê–ª–≥–æ—Ä–∏—Ç–º:</label>
                    <select id="algorithm">
                        <option value="perlin">Perlin Noise</option>
                        <option value="diamond">Diamond-Square</option>
                        <option value="hybrid" selected>–ì–∏–±—Ä–∏–¥–Ω—ã–π</option>
                    </select>
                </div>
                <button id="generate" class="generate-btn">üéØ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ª–∞–Ω–¥—à–∞—Ñ—Ç</button>
            </div>

            <div class="control-section">
                <h3>‚öôÔ∏è –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —à—É–º–∞</h3>
                <div class="control-group">
                    <label for="scale">–ú–∞—Å—à—Ç–∞–±:</label>
                    <input type="range" id="scale" min="10" max="500" value="120">
                    <span id="scaleValue">120</span>
                </div>
                <div class="control-group">
                    <label for="octaves">–û–∫—Ç–∞–≤—ã:</label>
                    <input type="range" id="octaves" min="1" max="10" value="4">
                    <span id="octavesValue">4</span>
                </div>
                <div class="control-group">
                    <label for="roughness">–®–µ—Ä–æ—Ö–æ–≤–∞—Ç–æ—Å—Ç—å:</label>
                    <input type="range" id="roughness" min="1" max="100" value="40">
                    <span id="roughnessValue">0.4</span>
                </div>
            </div>

            <div class="control-section">
                <h3>üî∑ Diamond-Square</h3>
                <div class="control-group">
                    <label for="dsRoughness">–®–µ—Ä–æ—Ö–æ–≤–∞—Ç–æ—Å—Ç—å DS:</label>
                    <input type="range" id="dsRoughness" min="1" max="100" value="50">
                    <span id="dsRoughnessValue">0.5</span>
                </div>
                <div class="control-group">
                    <label for="hybridWeight">–°–º–µ—à–∏–≤–∞–Ω–∏–µ:</label>
                    <input type="range" id="hybridWeight" min="0" max="100" value="40">
                    <span id="hybridWeightValue">40%</span>
                </div>
            </div>

            <div class="control-section">
                <h3>üèîÔ∏è –†–µ–ª—å–µ—Ñ</h3>
                <div class="control-group">
                    <label for="heightScale">–í—ã—Å–æ—Ç–∞:</label>
                    <input type="range" id="heightScale" min="10" max="200" value="50">
                    <span id="heightScaleValue">50</span>
                </div>
                <div class="control-group">
                    <label for="erosionIterations">–≠—Ä–æ–∑–∏—è:</label>
                    <input type="range" id="erosionIterations" min="0" max="10000" value="3000">
                    <span id="erosionValue">3000</span>
                </div>
                <div class="control-group">
                    <label for="smoothing">–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ:</label>
                    <input type="range" id="smoothing" min="0" max="100" value="30">
                    <span id="smoothingValue">30</span>
                </div>
            </div>

            <div class="control-section">
                <h3>üé® –í–Ω–µ—à–Ω–∏–π –≤–∏–¥</h3>
                <div class="control-group">
                    <label for="waterLevel">–£—Ä–æ–≤–µ–Ω—å –≤–æ–¥—ã:</label>
                    <input type="range" id="waterLevel" min="0" max="100" value="15">
                    <span id="waterLevelValue">15%</span>
                </div>
                <div class="control-group">
                    <label for="colorIntensity">–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —Ü–≤–µ—Ç–æ–≤:</label>
                    <input type="range" id="colorIntensity" min="50" max="200" value="100">
                    <span id="colorIntensityValue">100%</span>
                </div>
                <div class="view-controls">
                    <label>–†–µ–∂–∏–º:</label>
                    <button id="viewSolid" class="active">–¢–µ–∫—Å—Ç—É—Ä–∞</button>
                    <button id="viewWireframe">–°–µ—Ç–∫–∞</button>
                </div>
            </div>

            <div class="control-section">
                <h3>üíæ –≠–∫—Å–ø–æ—Ä—Ç</h3>
                <button id="export">üì• –≠–∫—Å–ø–æ—Ä—Ç –≤—ã—Å–æ—Ç</button>
                <button id="screenshot">üì∏ –°–Ω–∏–º–æ–∫</button>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
            <div class="loading-progress" id="loadingProgress">0%</div>
        </div>

        <div class="visualization">
            <div class="canvas-container">
                <div id="threeContainer"></div>
                <div class="tool-info" id="toolInfo">
                    <div>üîÑ Alt+–õ–ö–ú: –í—Ä–∞—â–∞—Ç—å –∫–∞–º–µ—Ä—É</div>
                    <div>üîç –ö–æ–ª–µ—Å–æ: –ú–∞—Å—à—Ç–∞–±</div>
                    <div>üì± –ü–ö–ú: –ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ</div>
                </div>
                <div class="legend">
                    <span>üü¶ –í–æ–¥–∞</span>
                    <span>üü® –ü–µ—Å–æ–∫</span>
                    <span>üü© –¢—Ä–∞–≤–∞</span>
                    <span>üü´ –ó–µ–º–ª—è</span>
                    <span>‚¨ú –°–∫–∞–ª—ã</span>
                    <span>‚ùÑÔ∏è –°–Ω–µ–≥</span>
                </div>
            </div>
            
            <div class="stats">
                <div id="minHeight">–ú–∏–Ω: 0.00</div>
                <div id="maxHeight">–ú–∞–∫—Å: 0.00</div>
                <div id="vertexCount">–í–µ—Ä—à–∏–Ω—ã: 0</div>
                <div id="algorithmInfo">–ê–ª–≥–æ—Ä–∏—Ç–º: –ì–∏–±—Ä–∏–¥–Ω—ã–π</div>
                <div id="generationTime">–í—Ä–µ–º—è: 0—Å</div>
            </div>
        </div>
    </div>

    <script src="perlin.js"></script>
    <script src="diamondSquare.js"></script>
    <script src="erosion.js"></script>
    <script src="threeRenderer.js"></script>
    <script src="main.js"></script>
</body>
</html>